<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greenhouse Solver</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        h1 { margin-bottom: 10px; }
        p { color: #aaa; margin-bottom: 20px; }

        .container {
            display: flex;
            gap: 50px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .grid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .grid-label {
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mini-btn {
            padding: 8px 15px;
            font-size: 0.9rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            transition: opacity 0.2s;
        }
        .mini-btn:hover { opacity: 0.8; }
        .btn-red { background-color: #e74c3c; }
        .btn-green { background-color: #2ecc71; color: #1a1a1a; font-weight: bold; }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-template-rows: repeat(10, 40px);
            gap: 2px;
            background-color: #333;
            border: 5px solid #444;
            border-radius: 4px;
        }

        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            transition: background 0.1s;
        }

        /* Input Grid Styles */
        .cell.green { background-color: #2ecc71; color: #1a1a1a; } /* Empty (0) */
        .cell.red { background-color: #e74c3c; color: white; }     /* Wall (-1) */

        /* Output Grid Styles */
        .cell.melon { background-color: #27ae60; color: white; }
        .cell.pumpkin { background-color: #d35400; color: white; }
        .cell.empty-res { background-color: #2c3e50; }
        .cell.wall-res { background-color: #333; }

        .main-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.2rem;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .main-btn:active { transform: scale(0.95); }
        .main-btn:disabled { background-color: #555; cursor: wait; }

        #stats {
            margin-top: 20px;
            font-size: 1.1rem;
            color: #f1c40f;
        }
    </style>
</head>
<body>

    <h1>Greenhouse Solver</h1>
    <p>Click cells to toggle between Wall (-1) and Empty (0).</p>

    <div class="container">
        <div class="grid-container">
            <div class="grid-label">Input Layout</div>
            
            <div class="controls">
                <button class="mini-btn btn-red" onclick="setAll(-1)">Set All Walls</button>
                <button class="mini-btn btn-green" onclick="setAll(0)">Set All Empty</button>
            </div>

            <div id="inputGrid" class="grid"></div>
        </div>

        <div class="grid-container">
            <div class="grid-label">Solution</div>
            <div class="controls" style="visibility: hidden;">
                <button class="mini-btn">Spacer</button>
            </div>
            <div id="outputGrid" class="grid"></div>
        </div>
    </div>

    <button id="solveBtn" class="main-btn" onclick="runSolver()">Calculate Optimization</button>
    <div id="stats"></div>

<script>
    const ROWS = 10;
    const COLS = 10;
    
    // Arrays representing the grids
    // inputData: 0 = Empty, -1 = Wall
    // Initialized to -1 (Wall) by default now
    let inputData = Array(ROWS).fill().map(() => Array(COLS).fill(-1));
    let resultGrid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let minItems = 999;
    
    // Neighbors lookup
    const rowMove = [-1, -1, -1, 0, 0, 1, 1, 1];
    const colMove = [-1, 0, 1, -1, 1, -1, 0, 1];

    // Memoization Table
    let memo = null; 

    // --- UI FUNCTIONS ---

    function initGrids() {
        const inputDiv = document.getElementById('inputGrid');
        const outputDiv = document.getElementById('outputGrid');

        inputDiv.innerHTML = '';
        outputDiv.innerHTML = '';

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                // Input Cell
                const iCell = document.createElement('div');
                iCell.id = `in-${r}-${c}`;
                // Default to Wall (-1) logic
                iCell.className = 'cell red'; 
                iCell.innerText = 'X';
                
                iCell.onclick = () => toggleCell(r, c);
                inputDiv.appendChild(iCell);

                // Output Cell (Placeholder)
                const oCell = document.createElement('div');
                oCell.className = 'cell empty-res';
                oCell.id = `out-${r}-${c}`;
                outputDiv.appendChild(oCell);
            }
        }
    }

    function toggleCell(r, c) {
        const el = document.getElementById(`in-${r}-${c}`);
        if (inputData[r][c] === 0) {
            // Switch to Wall
            inputData[r][c] = -1;
            el.className = 'cell red';
            el.innerText = 'X';
        } else {
            // Switch to Empty
            inputData[r][c] = 0;
            el.className = 'cell green';
            el.innerText = '';
        }
    }

    // New Function to set all cells at once
    function setAll(val) {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                inputData[r][c] = val;
                const el = document.getElementById(`in-${r}-${c}`);
                if (val === -1) {
                    el.className = 'cell red';
                    el.innerText = 'X';
                } else {
                    el.className = 'cell green';
                    el.innerText = '';
                }
            }
        }
    }

    function renderOutput(items) {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.getElementById(`out-${r}-${c}`);
                const val = resultGrid[r][c];
                cell.className = 'cell';
                cell.innerText = '';

                if (val === -1) {
                    cell.classList.add('wall-res');
                    cell.innerText = 'X';
                } else if (val === 1) {
                    cell.classList.add('melon');
                    cell.innerText = 'M';
                } else if (val === 2) {
                    cell.classList.add('pumpkin');
                    cell.innerText = 'P';
                } else {
                    cell.classList.add('empty-res');
                }
            }
        }
        document.getElementById('stats').innerText = `Minimum Items Needed: ${items}`;
    }

    // --- SOLVER ALGORITHM ---

    function runSolver() {
        const btn = document.getElementById('solveBtn');
        btn.disabled = true;
        btn.innerText = "Calculating...";
        document.getElementById('stats').innerText = "Running algorithm...";

        setTimeout(() => {
            const start = performance.now();
            
            minItems = 999;
            // 1 << 20 is 1048576 (hash size)
            if (!memo) {
                memo = new Int8Array((ROWS * COLS + 1) * (1 << 20));
            }
            // Fill memo with 127 (max int8) to represent 'infinity'
            memo.fill(127); 

            // Copy inputData for the solver to work on
            let workingGrid = inputData.map(row => [...row]);
            
            solveTheGrid(0, 0, workingGrid);

            const end = performance.now();
            console.log(`Time: ${(end - start).toFixed(2)}ms`);

            renderOutput(minItems);
            btn.disabled = false;
            btn.innerText = "Calculate Optimization";
        }, 50);
    }

    function isSatisfied(r, c, grid) {
        if (grid[r][c] !== 0) return true;

        let hasMelon = false;
        let hasPumpkin = false;

        for (let k = 0; k < 8; k++) {
            let nr = r + rowMove[k];
            let nc = c + colMove[k];
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                if (grid[nr][nc] === 1) hasMelon = true;
                if (grid[nr][nc] === 2) hasPumpkin = true;
            }
        }
        return hasMelon && hasPumpkin;
    }

    function checkEverything(grid) {
        for (let i = 0; i < ROWS; i++) {
            for (let j = 0; j < COLS; j++) {
                if (!isSatisfied(i, j, grid)) return false;
            }
        }
        return true;
    }

    function solveTheGrid(index, itemCount, grid) {
        if (itemCount >= minItems) return;

        // --- MEMOIZATION ---
        if (index > 0) {
            let hash = 0;
            for (let k = 1; k <= COLS; k++) {
                let pIdx = index - k;
                let val = 0;
                if (pIdx >= 0) {
                    let pr = Math.floor(pIdx / COLS);
                    let pc = pIdx % COLS;
                    let v = grid[pr][pc];
                    val = (v === -1) ? 3 : v;
                }
                hash = (hash << 2) | val;
            }

            let mIdx = index * 1048576 + hash;
            
            if (itemCount >= memo[mIdx]) return;
            memo[mIdx] = itemCount;
        }

        // Base Case
        if (index >= ROWS * COLS) {
            if (checkEverything(grid)) {
                minItems = itemCount;
                for(let i=0; i<ROWS; i++) {
                    for(let j=0; j<COLS; j++) {
                        resultGrid[i][j] = grid[i][j];
                    }
                }
            }
            return;
        }

        let r = Math.floor(index / COLS);
        let c = index % COLS;

        // --- OPTIMIZATION 1: Previous Diagonal ---
        if (r > 0 && c > 0) {
            let pr = r - 1;
            let pc = c - 1;
            if (grid[pr][pc] === 0) {
                let hasMelon = false;
                let hasPumpkin = false;
                for (let k = 0; k < 8; k++) {
                    let nr = pr + rowMove[k];
                    let nc = pc + colMove[k];
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        if (grid[nr][nc] === 1) hasMelon = true;
                        if (grid[nr][nc] === 2) hasPumpkin = true;
                    }
                }

                if (!hasMelon && !hasPumpkin) return;

                if (!hasMelon) {
                    if (grid[r][c] === -1) return;
                    grid[r][c] = 1;
                    solveTheGrid(index + 1, itemCount + 1, grid);
                    grid[r][c] = 0;
                    return;
                }
                if (!hasPumpkin) {
                    if (grid[r][c] === -1) return;
                    grid[r][c] = 2;
                    solveTheGrid(index + 1, itemCount + 1, grid);
                    grid[r][c] = 0;
                    return;
                }
            }
        }

        // --- OPTIMIZATION 2: End of Previous Row ---
        if (c === 0 && r > 1) {
            let pr = r - 2;
            let pc = COLS - 1;
            if (!isSatisfied(pr, pc, grid)) return;
        }

        // Skip Wall
        if (grid[r][c] === -1) {
            solveTheGrid(index + 1, itemCount, grid);
            return;
        }

        // --- OPTIMIZATION 3: Future Feasibility ---
        let canBeZero = true;
        let mCount = 0;
        let pCount = 0;
        let futurePotential = 0;

        for (let k = 0; k < 8; k++) {
            let nr = r + rowMove[k];
            let nc = c + colMove[k];
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                if (grid[nr][nc] === 1) mCount++;
                else if (grid[nr][nc] === 2) pCount++;
                else if ((nr * COLS + nc) > index && grid[nr][nc] !== -1) futurePotential++;
            }
        }

        if (mCount === 0 && futurePotential < 1) canBeZero = false;
        if (pCount === 0 && futurePotential < 1) canBeZero = false;
        if (mCount === 0 && pCount === 0 && futurePotential < 2) canBeZero = false;

        if (canBeZero) {
            grid[r][c] = 0;
            solveTheGrid(index + 1, itemCount, grid);
        }

        // Try Melon
        grid[r][c] = 1;
        solveTheGrid(index + 1, itemCount + 1, grid);

        // Try Pumpkin
        grid[r][c] = 2;
        solveTheGrid(index + 1, itemCount + 1, grid);

        // Backtrack
        grid[r][c] = 0;
    }

    // Initialize on Load
    initGrids();

</script>
</body>
</html>